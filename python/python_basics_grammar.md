# 이론 07.21

## 인터프리터 언어

- 파이썬은 인터프리터 언어다!

### 인터프리터를 사용하는 방법 1

```python
#터미널에서 python으로 진입
$ python -i

#터미널이 python으로 변경되었는지 확인 후, 원하는 코드 입력
>>> print('hello')
hello

#python 터미널에서 빠져나오기
>>> exit()
```

- 일반적으로 1번 방법은 잘 쓰지 않는다.

### 인터프리터를 사용하는 방법2

```python
#터미널에서 'cd [원하는 폴더명]'을 입력하여 진입
$ cd [원하는 폴더명]

#터미널에 ls를 입력해서 현재 진입한 폴더에 있는 파일들 확인 가능
$ ls

#'python [파일명]'을 입력해 현재 파일의 코드 실행 가능
$ python [파일명.py]
<실행결과>

```

## 표현식

- 하나의 ‘값’으로 평가될 수 있는 모든 코드

### 표현식 예시

- 3 + 5
- x > 10 등…

## 값

- 표현식이 평가된 결과
- 더 이상 계산되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각
  - **평가**: 표현식을 계산하여 그 결과인 '값'을 만들어내는 과정

### 값 예시

- 숫자 값: 103.14
- 문자열 값: "안녕하세요"
- 불리언 값: True, False
  - **불리언(Boolean)**: 컴퓨터에서 참과 거짓을 나타내는 숫자 1과 0만을 이용하는 방식

### 표현식, 평가 그리고 값

- 표현식을 평가하면 하나의 값이 됨
- 표현식: 3 + 5 같은, 값으로 평가될 수 있는 코드
- 평가: 표현식을 계산하여 값을 만들어 냄
- 값: 표현식이 평가된 결과 (8)

## 변수와 메모리

### 변수

값을 나중에 사용하기 위해, 그 값에 붙여 주는 이름

> 객체를 가리키는 이름

> “이름표”라고 생각하면 쉬움. (변수=값을 담는 상자라는 표현은, 직관적으로 이해하기는 쉽지만, 변수가 실제로 값을 가지고 있는 것은 아니고 단지 ‘이름표’이기 때문에 기술적으로는 틀린 표현이다.)

### 변수 할당

표현식이 만들어 낸 값에 이름을 붙이는 과정 (assignment)

- degrees = 36.5 ← degress라는 변수 이름에, “=”라는 할당 연산자를 사용해서, 36.5라는 표현식을 저장(할당)한다.
- “=”는 수학에서의 “같다”가 아니라, 오른쪽의 값을 왼쪽 변수에 ‘할당’한다는 뜻입니다.

### 변수명 규칙

- 알파벳, 언더스코어, 숫자로 구성
- 숫자로 시작할 수 없음
- 대소문자를 구분
- 아래 키워드는 파이썬의 내부 예약어로 사용할 수 없다.
  - False, None, True, __ peg_parser __ (띄어쓰기 없이 입력), and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield

- 변수명은 사람이 직관적으로 알아보기 편하게 붙여주는, 인간 친화적인 이름이다

### 메모리

- 거리에 집 주소가 있듯이 메모리의 모든 위치에는 그 위치를 고유하게 식별하는 메모리 주소가 존재한다.
- 고유한 ID (메모리 주소)
  - 제품의 바코드 (같은 느낌)
- 타입 (Type)
  - 제품의 종류 (예: 정수, 실수, 문자열 등)
- 값 (Value)
  - 제품의 실제 내용물
- 값+타입+주소 정보를 묶은 것을 **객체(Object)** 라고 부름
- 변수는 특정 객체를 ‘가리키는’ 이름
- 변수는 메모리 주소를 ‘가지지(contain)’않는다.

### 재할당

- 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것

### 재할당 점검

``` python
number = 10
double = 2 * number
print(double) # 20

number = 5
print(double) # ?

double = 2 * number
print(double) # ??
```
- 여기에서 두번째 double의 값은 무엇일까?
- 답은 20이다.
- number을 밑에서 재할당했지만, double는 재할당되지 않았기에, 여전히 double에서는 초기에 할당된 number의 주소와 값을 가져오기 때문이다.
- 그러므로 재할당이 진행된 세 번째 double의 값은 10이 된다.

## Data Types

### Type

- 변수나 값이 가질 수 있는 데이터의 종류를 의미
- 어떤 종류의 데이터인지, 어떻게 해석되고 어떻게 해석되어야 하는지 정의

### 타입의 구성 요소 2가지

- 값(피연산자)와 연산자(값에 적용할 수 있는 연산)

### 데이터 타입이 필요한 이유

- 각 타입에 따라 가능한 기능과 연산이 다르기 때문
- 숫자는 더하기 가능
- 문자열은 결합 가능
- 숫자와 문자는 더할 수 없음 → 오류 발생

### 데이터 타입 분류 5가지
- Numeric Types
  - int(정수), float(실수), complex(복소수)
- Text Sequence Type
  - str(문자열)
- Seqence Type
  - list, tuple, range
- Non-sequence Types
  - set, dict
- 기타
  - Boolean, None, Functions

### 숫자형 데이터 Numeric Types

- 프로그래밍에서 값을 계산하고, 수량을 세고, 데이터를 분석하는 등 가장 기본이 되는 데이터 타입
- 정수형 int: 소수점이 없는 숫자
- 실수형 float: 소수점이 있는 숫자
    - **지수 표현법**
    
        아주 크거나 아주 작은 실수를 간결하게 표현하기 위해 사용하는 방식
        
        **지수**: 어떤 수를 그 자신과 여러 번 곱할 때, 그 곱하는 횟수를 나타내는 수 (거듭제곱에서 오른쪽 위에 작게 쓰이는 숫자)
        

```jsx
# 1,230,000,000 (1.23 * 10^9)
big_number = 1.23e9
# 0.00314 (3.14 * 10^-3)
small_number = 3.14e-3
```

### 숫자형의 ‘행동’ - 산술 연산

- 숫자형 데이터의 핵심 ‘행동’은 바로 계산
- 데이터 타입은 ‘값의 종류’와 ‘적용 가능한 행동’의 묶음
- 파이썬은 다양한 계산을 위한 산술 연산자를 제공

- 산술 연산자
  - 덧셈 ( + )
  - 뺄셈 ( - )
  - 곱셈 ( * )
  - 나눗셈 ( / )
  - 몫 나눗셈 ( // )
  - 나머지 ( % )
  - 거듭제곱 ( ** )
  - 음수 부호 ( ** )
- 수학과 마찬가지로, 파이썬도 정해진 순서에 따라 연산을 수행
  - 우선순위 높음 ( ** > - > *, / , // , % )
  - 우선순위 낮음 ( + , - )
- 순서가 헷갈릴 때는 소괄호 ‘()’ 사용

- **연산자 우선순위 점검**
``` python
    # -16
    -2 ** 4

    # -16
    -(2 ** 4)

    # 16
    (-2) ** 4
```

- 연산자 우선순위가 제곱(지수)가 더 높다.
- 1번이 헷갈리기 쉽지만, 연산자 우선순위 때문에 1번과 2번은 계산 순서가 같아지고, 1번 답이 -16이 된다.
- 이런 면에서 수학과는 조금 다름!!

### 시퀀스 타입 Sequence Types

- 여러 개의 값(데이터)들을 순서대로, 일렬로 나열하여 저장하는 자료형
- **str**, list, tuple, range 등…
- **스트링(string)도 시퀀스 타입이라는 것 잊지 말자!!**
- **인덱스index**
    
    시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호
    
    이 번호를 통해 원하는 데이터에 바로 접근 가능
    

### 시퀀스 타입의 특징

1. 순서
   - 값들이 순서대로 저장 (정렬 X)
2. 인덱싱
   - 각 값에 고유 번호(인덱스)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
3. 슬라이싱
   - 인덱스 범위를 조절해 전체 데이터 중 원하는 부분만 값을 잘라내서 사용할 수 있음
4. 길이
   - len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
5. 반복
   - 반복문을 사용하여 각 값을 하나씩 순서대로 꺼내 사용할 수 있음

### 문자열 str

- 문자들의 순서가 있는, 변경 불가능한 시퀀스 자료형
1. **문자열 만들고 표현하기**
    - 작은따옴표(’) 또는 큰따옴표(”)로 감싸서 표현
    - 단, 혼용해서 사용하기보다 결정한 한가지 방식으로 통일하는 것 권장
    - 따옴표 안에 다른 따옴표를 넣고 싶을 때는 서로 다른 종류의 따옴표를 사용
    - **이스케이프 시퀀스**
       - 역슬래시 ( \ )와 문자를 조합해 특별한 기능 수행
       ``` python
       # 따옴표 앞에 \ 를 붙여 문자로 인식시킴.
       print('He\'s a boy.')
       # 출력 결과: He's a boy.

       # \n 은 줄바꿈(엔터)을 의미함
       print('첫째 줄\n둘째 줄')

       # 여러 줄 문자열을 작성할 때는 """ 또는 ''' 사용
       multi_line_str = """
       이것은
       여러 줄로 이루어진
       문자열입니다.
       """
       print(multi_line_str)
       ```
        - **이스케이프 시퀀스 예약 문자 정리**
          - \n : 줄 바꿈
          - \t : 탭
          - \\ : 백슬래시
          - \' : 작은 따옴표
          - \" : 큰 따옴표

    - **f-string** 활용하기
        - 문자열 내에 변수나 표현식의 결과를 손쉽게 삽입하는 강력한 방법
        - 문자열 시작 전 ‘f’ 접두어를 붙이고, 삽입할 부분(표현식)을 중괄호 {}로 감싸줌
        - 심화 사용법 더 찾아보기!!
        ``` python
        name = '홍길동'
        age = 25

        greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'
        # 안녕하세요, 제 이름은 홍길동이고 나이는 25살입니다.
        print(greeting)
        ```

        
2. **시퀀스로서 활용하기**
    - 문자열은 시퀀스이므로 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능
    ``` python
    my_str = 'Hello'
    ```
    | 특징     | 사용 예시                  | 결과             | 설명                                |
    |----------|----------------------------|------------------|-------------------------------------|
    | 인덱싱   | `my_str[1]  `              | `'e'  `          | 1번 위치의 글자 선택                |
    | 슬라이싱 | `my_str[1:4] `             | `'ell'`          | 1번부터 4번 앞까지 부분 추출       |
    | 길이     | `len(my_str)`              | `5`              | 문자열의 전체 길이                 |
    |    반복     | `for char in my_str:`      | `H, e, l, l, o`  | 각 문자를 순서대로 처리            |

    
    - **인덱스**
        - 인덱스는 왜 0부터 시작할까?
        - 프로그래밍에서 인덱스가 1이 아닌 0부터 시작하는 것은 거리의 개념으로 이해하면 쉽다.
            - 인덱스는 시작점부터 얼마나 떨어져 있는가를 의미한다.
            - 첫 번째 값은 시작점 바로 그 자체이므로, 떨어진 거리가 0이다.
            - 두 번째 값은 시작점에서 1만큼 떨어져 있다.
            
            따라서 index 0은 첫 번째 항목을 의미. 대부분의 프로그램에서 통용된다.
            
        - 파이썬은 음수 인덱스를 지원한다!

            | 문자   | h   | e   | l   | l   | o   |
            |--------|-----|-----|-----|-----|-----|
            | 양수 인덱스 | 0   | 1   | 2   | 3   | 4   |
            | 음수 인덱스 | -5  | -4  | -3  | -2  | -1  |

        
    - 슬라이싱 (Slichin)
        - 시퀀스의 일부분을 잘라내어 새로운 시퀀스를 만드는 작업
        - 시작 인덱스와 끝 인덱스를 지정항 해당 범위의 값을 포함하는 새로운 시퀀스를 생성한다.
        

        - **슬라이싱의 생략**
          - my_str[:3]
            - hel
          - my_str[::2]
            - hlo
          - my_str[::-1]
            - olleh
        
3. **가장 중요한 규칙: 불변성**
   - 한번 생성된 문자열 객체는 그 내용을 절대 수정할 수 없다.
       - 문자열 변경을 시도하려 해도, "문자열 객체는 아이템 할당을 지원하지 않습니다"라는 에러가 발생.
   - 그렇다면 문자열을 바꾸기 위해서는?
     - 기존 문자열의 일부와 새로운 값을 조합하여 새로운 문자열을 만들어야 함.



# 이론 07.22

## 리스트

- 여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료
- 대괄호 안에 값들을 쉼표(,) 로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음

```python
# 리스트 표현
my_list_1 = []
my_list_2 = [1, 'a', 3, 'b', 5]
my_list_3 = [1, 2, 3, 'python', ['hello', 'world', '!!!']]
```

### 리스트의 시퀀스 특징

- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능

```python
# 인덱싱
print(my_list[1])  # a

# 슬라이싱
print(my_list[2:4])  # [3, 'b']
print(my_list[:3])  # [1, 'a', 3]
print(my_list[3:])  # ['b', 5]
print(my_list[::2])  # [1, 3, 5]
print(my_list[::-1])  # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list))  # 5
```


### 중첩 리스트

- 다른 리스트를 값으로 가진 리스트
- 중첩 리스트 접근하기: 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음
    1. 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
        1. my_list[4] → [’hello’, ‘world’, ‘!!!’]
    2. 선택된 안쪽 리스트에 다시 한번 인덱스를 사용
        1. my_list[4][-1] → [’!!!’]

```python
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]

print(len(my_list)) #5
print(my_list[4][-1]) # !!!
print(my_list[-1][1][0]) # w
```

- 마지막 예시 → **‘문자열도 시퀀스이기 때문에 선택 가능’!!!** 잊지 말기

### 리스트의 가변성Mutability

- 한번 생성된 리스트는 내용을 자유롭게 수정, 추가, 삭제할 수 있다.
- 이는 문자열의 불변성(immutability)과 정반되는 매우 중요한 특징!
    - 인덱싱으로 값 수정하기
    
    ```python
    my_list = [1, 2, 3, 4, 5]
    
    my_list[1] = 'two'
    
    print(my_list) # [1, 'two', 3, 4, 5]
    ```
    
    - 슬라이싱으로 여러 값 한번에 바꾸기
    
    ```python
    my_list = [1, 2, 3, 4, 5]
    
    my_list[2:4] = ['three', 'four']
    
    print(my_list) # [1, 2, 'three', 'four', 5]
    ```

## 튜플tuple

- 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형
- 소괄호 () 안에 값들을 쉼표(,) 로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음

```python
# 튜플 표현
my_tuple_1 = ()
my_tuple_2 = (1) => 1
#요소가 하나인 튜플은 이렇게 만들면 안 된다. 괄호가 벗겨진다

my_tuple_2 = (1,)
#이렇게 만들어야 튜플이다!!

my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True
```

- 소괄호 없이도 만들 수 있다.
- 단일 요소 튜플을 만들 때는 반드시 Trailing comma(후행 쉼표)를 사용해야 한다. (1,) ← 이거

- 튜플의 시퀀스 특징
    - 튜플 역시 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있다.

```python
my_tuple = (1, 'a', 3, 'b', 5)

# 인덱싱
print(my_tuple[1]) # a

# 슬라이싱
print(my_tuple[2:4]) # (3, 'b')
print(my_tuple[:3]) # (1, 'a', 3)
print(my_tuple[3:]) # ('b', 5)
print(my_tuple[::2] # (1, 3, 5)
print(my_tuple[::-1]) # (5, 'b', 3, 'a', 1)

#길이
print(len(my_tuple)) # 5
```

### 튜플의 불변성

- 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음

```python
my_tuple = (1, 'a', 3, 'b', 5)

my_tuple[1] = 'z'
# TypeError : 'tuple' object does not support item assignment
# '튜플' 객체가 항목 할당을 지원하지 않습니다. (수정 못한다는 뜻)
```

### 튜플은 어디에 쓰일까? (튜플이 불변 자료형인 이유)

- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨
- 다중 할당, 값 교환, 함수 다중 반환 값 등

```python
# 다중 할당
x, y = 10, 20
print(x) # 10
print(y) # 20

#실제 내부 동작. 튜플을 이용해서 동작한다.
(x, y) = (10, 20)

#값 교환
x, y = 1, 2
x, y = y, x

#실제 내부 동작
temp = (y, x) # 튜플 생성
x, y = temp # 튜플을 풀어내면서 값이 반대로 들어감
print(x, y) # 2 1
```

- 튜플은 데이터의 “안전성과 무결성”을 보장한다!
- 개발자가 직접 쓰는 건 아니지만, 파이썬 내부에서 사용하고 있다!

## 레인지 range

- 연속된 정수 시퀀스를 **생성**하는, 변경 불가능한(immutable) 자료형
- 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 유용
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 ‘규칙’만 기억하여 메모리를 매우 효율적으로 사용

### range 기본 구문

- range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있다

```python
range(start, stop, step)
```

### range 매개변수별 특징

- range(stop)
    - 매개변수가 하나면 stop로 인식
    - start는 0이, step은 1이 기본값으로 자동 설정
    - range(5) → 0, 1, 2, 3, 4
- range(start, stop)
    - 매개변수가 두 개면 start와 stop으로 인식
    - step은 1이 기본값으로 자동 설정
    - range(2, 5) → 2, 3, 4
- range(start, stop, step)
    - 모든 매개변수를 직접 지정
    - range(2, 10, 2) → 2, 4, 6, 8
- range는 list로 형변환 시 내부 값을 확인할 수 있다.

```python
# range 표현
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

print(my_range_1) # range(0, 5)
print(my_range_2) # range(1, 10)
print(my_range_3) # range(5, 0, -1)

print(list(my_range_1)) # [0, 1, 2, 3, 4]
print(list(my_range_2)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(my_range_3)) # [5, 4, 3, 2, 1]
```

### range의 규칙

- 값의 범위 규칙
    - stop 값은 생성되는 시퀀스에 절대 포함되지 않음 (5가 stop라면 절대!!! 4까지만)
    - range(1, 5)는 1부터 5 ‘전’까지의 숫자를 의미하므로, 1, 2, 3, 4가 생성
- 증가/감소 값(step)규칙
    - step 값은 숫자 시퀀스의 간격과 방향을 결정
        1. step이 양수일 때 (기본값: 1)
            1. 숫자가 start부터 stop을 향해 증가
            2. range(1, 10, 2) → 1, 3, 5, 7, 9
        2. step이 음수일 때
            1. 숫자가 start부터 stop을 향해 감소
            2. 이 경우, start값은 stop 값보다 반드시 커야 함
            3. range(10, 1, -2) → 10, 8, 6, 4, 2


- step이 양수일 때 시작값이 끝 값보다 크면 => 빈 range
- 반대로 step가 음수일 때 시작값이 끝 값보다 작으면 => 역시 빈 range 생성
- 추후 반복문 챕터에서 자세히 공부할 예정

## 딕셔너리(딕트) dict

- key - value 쌍으로 이루어진, 순서와 중복이 없는 변경 가능한 자료형

### 딕셔너리 표현

- 중괄호 {} 안에 값들이 쉼표(,) 로 구분되어 있음
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- Key(키)
    - 값을 식별하기 위한 고유한 ‘이름표’ (Key는!! 중복 불가)
- Value(값)
    - 키에 해당하는 실제 데이터
- 각 값에는 순서가 없음
    - 딕셔너리는 순서가 없는 자료형이지만, 3.7 이상에서는 입력한 순서가 출력 시 그대로 유지된다!
    - 하지만 역시 '순서가 없다'. 즉 인덱스로 찾을 수 없다는 점, Key를 통해 접근해야 한다는 점 기억하기!

### 딕셔너리 규칙

- Key의 규칙
    - 고유해야 함
- 변경 불가능한(imable) 자료 만 사용 가능
    - 가능: str, int, float, tuple
    - 불가능 list, bict

Value 의 규칙

- 어떤 자료형이든 자유롭게 사용할 수 있음

### 딕셔너리 값 접근 방법

- Key를 사용하여 해당 Value를 꺼내 올 수 있음
- Key에 접근 시 [] 대괄호 사용

```python
my_dict = {'name': '홍길동', 'age': 25}

print(my_dict['name']) # 홍길동
print(my_dict['test']) # KeyError: 'test'
```

- 존재하지 않는 Key로 접근하면 KeyError가 발생하며 프로그램 멈춤
- 사전에서 단어(Key)를 찾아 뜻(Value)을 확인하는 것처럼,
딕셔너리는 Key를 통해 빠르게 Value에 접근한다.

### 딕셔너리 값 추가 및 변경

![image.png](attachment:8a31c36f-d3a4-42bb-a97c-a55dcc328e99:image.png)

- 언제 딕셔너리를 사용할까?
    - 데이터에 순서가 필요 없고, 각 데이터에 의미 있는 이름(Key)을 붙여 관리하고 싶을 때 사용
    (예: 사람의 인적 정보, 게임 캐릭터의 능력치 등)

## 세트 set

- 순서와 중복이 없는 변경 가능한 자료형

### 세트 표현

- {} 중괄호 안에 값들을 쉼표(,)로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능

```python
# 세트 표현
my_set_1 = set()
my_set_2 = {1, 2, 3}
my_set_3 = {1, 1, 1}
```

- 튜플이랑 조금 비슷한 위치라고 생각해도 좋을 것 같다. 집합 연산할 때 주로 사용

### 세트의 두 가지 핵심 특징

1. 중복을 허용하지 않음
    1. 똑같은 값은 단 하나만 존재할 수 있음
2. 순서가 없음
    1. 인덱싱이나 슬라이싱을 사용할 수 없음

```python
my_set_1 = set()
my_set_2 = {1, 2, 3}
my_set_3 = {1, 1, 1}

print(my_set_1) # set()
print(my_set_2) # {1, 2, 3}
print(my_set_3) # {1}
```

- 비어 있는 딕셔너리와의 혼동을 피하기 위해, 비어 있는 세트는 반드시 set() 함수로 만들어야 한다.

### 세트의 집합 연산

- 세트는 수학의 ‘집합’ 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는 데 매우 효과적
```python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2) # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2) # {1, 2}

# 교집합
print(my_set_1 & my_set_2) # {3}
```


# Other type

## None

- 파이썬에서 ‘값이 없음’을 표현하는 특별한 데이터 타입
- 마치 내용물이 없는 ‘빈 상자’와 같다.
- 숫자 0이나 빈 문자열(’’) 과는 다른, ‘값이 존재하지 않음’, 또는 ‘아직 정해지지 않음’이라는 상태를 나타내기 위해 사용
```python
# my_variable에는 아직 아무 값도 할당하고 싶지 않을 때

my_variable = None

print(my_variable) # None
```

## Boolean

- ‘참(True)’과  ‘거짓(False)’, 단 두 가지 값만 가지는 데이터 타입
- 마치 ON-OFF 스위치처럼,
프로그램의 흐름을 제어하는 조건문에서 ‘맞다’또는 ‘틀리다’를 판단하는 역할을 한다

```python
# 비교/논리 연산의 평가 결과로 사용됨

is_active = True
is_logged_in = False

print(is_active) # True
print(is_logged_in) # False
print(10 > 5) # True
print(10 == 5) # False
```

- 주로 조건/반복문과 함께 사용된다.

## Collection

- 여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말
- 여러 물건을 담는 ‘보관함’과 같으며, 파이썬은 목적에 따라 다양한 종류의 컬렉션을 제공한다.
- str, list, tuple, range, set, dict 데이터 타입이 모두 Collection에 분류
- 순서 존재 여부에서: O = 시퀀스, X = 비시퀀스

### 불변 vs 가변
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 '불변'과 '가변' 두 그룹으로 나뉜다.

  | 구분   | 불변 (Immutable)                 | 가변 (Mutable)              |
  |--------|----------------------------------|------------------------------|
  | 특징   | 변경 불가, 안정성, 예측 가능     | 변경 가능, 유연성, 효율성   |
  | 종류   | `str`, `tuple`, `range`          | `list`, `dict`, `set`       |

```python
# 불변
my_str = 'hello'

my_str[0] = 'z'
# TypeError: 'str' object does not support item assignment
# 스트링 객체는 변경을 지원하지 않는다.

# 가변
my_list = [1, 2, 3]
my_list[0] = 100
print(my_list) # [100, 2, 3]
```

## 형변환 Type Conversion

- 예를 들어, 문자열 “100”을 숫자 100으로 바꾸거나, 숫자 3.14를 정수 3으로 바꾸는 듯 데이터의 ‘형태’를 필요에 따라 바꾸는 것.
- 형변환은 2가지가 있다:
    1. 암시적 형변환: 파이썬이 자동으로 처리
    2. 명시적 형변환: 개발자가 직접 지시

### 암시적 형변환 Imlpicit Conversion

- 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
- 암시적 형변환은 파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙.
- 마치 작은 ‘정수 상자’와 큰 ‘실수 상자’의 내용물을 합칠 때, 더 안전하게 담을 수 있는 큰 ‘실수 상자’로 알아서 옮겨 닯는 것과 같다.
- 개발자가 신경 쓰지 않아도 “더 안전한 쪽으로” 파이썬이 처리해주는 것

### 명시적 형변환

- 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
- 명시적 형변환은 서로 다른 타입의 데이터를 ‘호환’되도록 맞추는 과정
- 마치 해외에서 다른 모양의 전기 콘센트에 맞는 ‘어댑터’를 끼우는 느낌
- 파이썬은 타입에 엄격해서, 정수와 문자열을 바로 더할 수 없는 것처럼 모양이 다른 플러그는 바로 연결할 수 없다.
- 전부 외우라는 게 아니라, 대표 케이스는 알고 있으면 좋음

## 연산자

### 산술 연산자

- 수학적 계산을 위해 사용되는 연산자 (위에 있음!!)

### 복합 연산자

- 연산과 할당이 함께 이루어진다.

### 비교 연산자

- 두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 또는 False로 반환
- is 대신 ==를 사용해야 하는 이유
    - 결론: is는 ‘정체성’을, ==는 가치를 비교하기 때문
    - 두 연산자는 “같다”를 확인하는 목적이 근본적으로 다름
    - is (identity Operator)
        - 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지, 즉 ‘정체성’이 같은지를 확인
    - == (Equality Operator)
        - 두 변수가 가리키는 객체의 내용, 즉 ‘값value’이 같은지를 확인

- is 연산자는 언제 사용하는가?
    - 주로 싱글턴 객체를 비교할 때 사용
- 싱글턴(Singleton) 객체란?
    - 특정 값에 대해 파이썬 전체에서 단 하나의 개체만 생성되어 재사용되는 특별한 객체
    - 여러 변수가 이 값을 가지더라도, 모두 미리 만들어낸 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
    - 파이썬의 대표적인 싱글턴 객체: None, True, False

### ==와 is 정리

- 값 비교에는 ==을 사용하고, 객체(레퍼런스)비교에는 is를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값)을 판단해야 할 때 is를 쓰면 의도치 않은 결과 (False)가 나올 수 있으며, 이는 파이썬 내부적인 최적화나 타입 차이로 인해 일관성이 깨질 수 있기 때문
- is는 주로 싱글턴 객체에 대한 비교 시 사용

### 논리 연산자

- 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용 (and, or, not이 대표적)
- 이름이 앨리스인 게 True로 뜨면 뒤의 나이는 평가하지 않는다. 그게 바로 단축 평가다.

### 단축 평가

- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
- 컴퓨터는 꼭 필요한 계산만 하고, 결과가 이미 정해졌다면 굳이 뒤에 있는 코드까지 확인하지 않는다.

- 단축 평가 동작 정리
    - and 연산자
        - 하나라도 ‘거짓’이면 바로 ‘거짓’
        - and는 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 ‘거짓’값을 반환
        - 만약 끝까지 갔는데 모든 값이 ‘참’이면, 맨 마지막 ‘참’ 값을 반환
    - or 연산자
        - 하나라도 ‘참’이면 바로 ‘참’
        - or는 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 ‘참’ 값을 바로 반환
        - 만약 끝까지 갔는데 모든 값이 ‘거짓’이면, 맨 마지막 ‘거짓’ 값을 반환

- 단축 평가를 하는 이유
    - 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함
    - 단순히 True/False 논리 연산을 넘어, 이처럼 코드의 흐름을 제어하고, 오류를 방지하며, 간결한 코드를 작성하는 데 매우 유용하게 사용되는 파이썬의 중요한 기능

### 멤버십 연산자

- 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
  - in: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인
  - not in: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인

### 시퀀스형 연산자

- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- ‘+’는 시퀀스를 연결하는 기능을, ‘*’는 시퀀스를 반복하는 기능을 함


### 연산자 우선순위

- 수학 기호처럼 연산자도 우선순위를 가진다.
    

# 참고

## 정수형의 진법 표현

### 코드에서 진법 표현하기

- 파이썬은 코드 내에서 다양한 진법의 숫자를 직접 표현할 수 있도록 특별한 접두사 (prefix)를 제공

## 실수의 함정, 부동소수점 오차

### 실수의 이상한 계산 결과

### 부동소수점 (반올림) 오차 (Floating-point Rounding Error)

- 발생 원인
    1. 컴퓨터는 2진법 사용
    2. 무한 소수의 발생과 근사값 저장
        - 우리가 쓰는 10진수 소수  중 일부는 2진수로 바꾸면 무한히 반복되는 무한 소수가 된다
        - 0.1 (10진수) → 0.0001100110011… (2진수)
        - 메모리는 유한하기 때문에, 컴퓨터는 이 무한 소수를 어쩔 수 없이 가장 가까운 근사값으로 잘라서 저장함
- 이 근사치 때문에 미세한 오차가 발생하고, 연산 과정에서 문제가 발생하게 될 수 있다.
- 해결책
    - 대표적으로 decimal 모듈을 사용해 부동소수점 연산의 정확성을 보장한다
    - decimal은 실수를 2진수로 변환하지 않고, 10진수 자체로 정확하게 연산할 수 있게 해준다.
    - 이외에도 다양한 해결 방법 존재

## 표현식과 문장

### 문장 (Statement)

- 특정 동작(action)을 지시하는, 실행 가능한 코드의 최소 단위
- 할당문, 조건문, 반복문… 여기서 문이 바로 문장(Statement)라는 의미를 가진다.
문장은 동작을 ‘기술’하는 것을 넘어, 그 자체로 완결된 하나의 명령이라는 의미가 강하다.
- 문장 예시
할당문( x = 100), 정의문(def my_function()), 제어문(pass, break, …) 등

### 표현식과 문장 구분하기

- “이 코드를 실행하면, 그래서 ‘하나의 값’이 남나요?
- 표현식 → 네
    - 어떻게든 계산되거나 평가되어 하나의 값으로 귀결된다 (변수에 담을 수 있다)
    - 10 + 20 → 값 30이 남음
    - len(”hello”) → 값 5가 남음
- 문장 → 아니오
    - 컴퓨터에게 특정 동작을 ‘지시’하고 끝남 (값 자체가 남지 않음)
    - name = “홍길동” → 값을 변수에 할당하라는 ‘지시’
- 문장은 표현식을 ‘재료’로 사용한다.
    - 요리법(문장)에 재료(표현식)가 사용될 수 있고,
    때로는 재료(표현식)하나만으로도 간단한 요리(문장)가 될 수 있다.

## Style Guide

- 코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항 모음
- 여러 사람이 함께 작업하거나, 미래의 내가 쉽게 알아보게 하기 위
- 파이썬의 경우 PEP 8 문서 존재

[PEP 8 – Style Guide for Python Code | peps.python.org](https://peps.python.org/pep-0008/)

### 파이썬에서의 대표적인 Style Guide

- 변수명은 무엇을 위한 변수인지 직관적인 이름을 가져야 함
- 공백(spaces) 4칸을 사용하여 코드 블록을 들여쓰기
- 한 줄의 길이는 79자로 제한하며, 길어질 경우 줄 바꿈을 사용
- 문자와 밑줄(_)을 사용하여 함수, 변수, 속성의 이름을 작성
- 함수 정의나 클래스 정의 등의 블록 사이에는 빈 줄을 추가
- 할당 연산자 좌우에는 공백(spaces) 1칸씩 주
    
    …
    
    (등등)
    

## 주석

- ctrl + /

## Python tutor

- 파이썬 코드가 한 줄씩 어떻게 실행되는지 눈으로 보여주는 시각화 도구
- [https://pythontutor.com/](https://pythontutor.com/python-compiler.html#mode=edit)


## Trailing Comma

- 컬렉션의 마지막 요소 뒤에 붙는 쉼표
    - 일반적으로 Trailing Comma 작성은 ‘선택사항’
    - 단, 하나의 요소로 구성된 튜플을 만들 때는 필수

- Trailing Comma 기본 규칙
    - 각 요소를 별도의 줄에 작성
    - 마지막 요소 뒤에 trailing comma 추가
    - 닫는 괄호는 새로운 줄에 배치

```python
# Trailing Comma 좋은 예시

items = [
	'item1',
	'item2',
	]
my_func(
	'value1',
	'value2',
	)
	
# 나쁜 예시

items = ['item1', 'item2',]
my_func('value1', 'value2',)

# 한 줄 작성 시에는 불필요하기 때문!!
```
    
    
- Trailing Comma 장점
    - 가독성 향상
        - 각 줄이 동일한 패턴을 가짐
        - 코드 리뷰가 용이함
    - 유지보수 용이성
        - 항목 추가/제거가 간단
        - 실수로 인한 구문 오류 방지


## 얕은 복사와 비교 연산자(is) 연습

```python
my_list = [1, 2, 3]
new_list = my_list

new_list[0] = 100
print(my_list)
# 얕은 복사. new_list와 my_list는 다른 변수지만, 서로 같은 것을 가리키고 있다.

my_list[1] = 200
print(new_list)
# my_list의 부분을 직접 수정했기 때문에, new_list가 가리키는 부분은 
# 여전히 my_list와 같으므로, 실행 결과는 [100, 200, 3]

print(my_list is new_list)
# 두 변수가 같은 객체를 가리키고 있기 때문에, True

my_list = [1, 2, 3]
print(new_list)
# my_list가 새롭게 할당된 다른 메모리의 리스트를 가리키게 되었고, 
# new_list는 여전히 본래의 리스크를 가리키고 있으므로,
# 실행 결과는 [100, 200, 3]

print(my_list is new_list)
# 두 변수가 다른 객체를 가리키게 되었기 때문에, False
```

## 얕은 복사와 깊은 복사

- 요약하자면 얕은 복사는 같은 객체를 다른 변수가 가리키는 복사다.
- 그러니까 메모리 주소가 똑같은 하나의 객체를 두 변수가 가리키고 있는 것임!!
- 왜 얕은 복사가 일어나냐면 파이썬의 자료형 중 수정 가능한 자료형들은 다른 객체로 새로 가리킨다고 해서 메모리가 새로 생성되지 않기 때문이다.
- 그래서 이러한 이뮤터블 자료형들을 얕은 복사로 복사해와서 수정했다가 서로 다른 변수의 객체들이 모두 바뀌는 사고가 일어나지 않게, 깊은 복사를 해줘야 된다.
- 깊은 복사의 원시적인 방법: 새로 직접 정의해주기
- 깔끔한 방법(추천): deepcopy 메서드 사용하기. (import copy 필요)

  [[파이썬/Python] 얕은 복사(Shallow copy)와 깊은 복사(deep copy)에 대한 완벽 정리](https://kevinitcoding.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%ACPython-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACShallow-copy%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACdeep-copy%EC%97%90-%EB%8C%80%ED%95%9C-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC)

- 서치하다가 발견했는데 읽기 쉬워서 첨부. 케빈님 감사합니다.